class Robot_arm

types 
    public MotorState = <ON> | <OFF>;

instance variables
    private env_q : real;
    private env_dq : real;
    private env_ddq : real;
    private env_motor_torque : real;
    -- private env_gravity_torque : real;
    private env_friction_torque : real;
    private env_inertia : real;

    private env_qt : real;
    private env_motor_state: MotorState;
    private last_time : real;
    private final_sim_time : real;
    public state_history : seq of (real * real * real)

values
    N1 : real = 0.0;
    N2 : real = 3.14/2;
    Q_em : real = 0.01;
    M1 : real = N1 + Q_em;
    M2 : real = N2 + Q_em;
    mass : real = 1.2;
    -- gravity : real = -9.81;
    radius : real = 0.8;
    friction_coulomb : real = 0.1;
    friction_viscous : real = 0.05;

sync
    mutex(getArmAngle, adjustArmPosition); -- getArmAngle and step are mutually exclusive
    mutex(getMotorState, setMotorState); -- getMotorState and setMotorState are mutually exclusive
    
    per isFinished => (time > final_sim_time); -- isFinished is true when time > final_sim_time


operations 
    public Robot_arm : () ==> Robot_arm
    Robot_arm() == (
        env_q := 0.0; -- angle of joint
        env_dq := 0.0; -- Angular velocity of joint
        env_ddq := 0.0; -- Angular acceleration of joint
        env_qt := 0.0; -- Target an
        env_inertia := mass * radius * radius; -- Mass moment of inertia
        -- env_gravity_torque := mass * gravity * radius * MATH`cos(env_q); -- Torque from gravity
        env_friction_torque := friction_coulomb * tanh(env_dq) + friction_viscous * env_dq; -- Torque from friction
        env_motor_torque := 0.0; -- Torque from the motor

        env_motor_state := <OFF>; 
        last_time := 0.0;
        final_sim_time := 0.0;
        state_history := [];
    );

    public tanh : (real) ==> (real)
    tanh(x) == ( 
        return (MATH`exp(x) - MATH`exp(-x)) / (MATH`exp(x) + MATH`exp(-x))
    );

    public setMotorState : (MotorState) ==> ()
    setMotorState (s) == duration (5e8) ( -- 0.5 sec
        env_motor_state := s;
    );

    public getMotorState : () ==> (MotorState)
    getMotorState () == duration (1e8) ( -- 0.1 sec
        return env_motor_state;
    );

    public getArmAngle : () ==> (real)
    getArmAngle () == duration (0) ( 
        return env_q;
    );

    public setTargetAngle : real ==> ()
    setTargetAngle (qt) == duration (1e8) ( -- 0.1 sec
        env_qt := qt;
    );

    public setMotorTorque : real ==> ()
    setMotorTorque (torque) == duration (0) (
        env_motor_torque := torque;
    );

    public setFinalSimTime : real ==> ()
    setFinalSimTime (t) == duration (0) (
        final_sim_time := t;
    );

    public recordState : () ==> ()
    recordState() == duration (0) (
        state_history := state_history ^ [mk_(round(time / 1e9), round(env_q), round(env_motor_torque))];
    );

    public isFinished : () ==> ()
    isFinished() == (skip);

    
    public round : (real) ==> real
    round(x) == (
        dcl y : real := x;
        y := y * 1000;
        y := floor y;
        y := y / 1000;
        return y

    );

    public adjustArmPosition : (real) ==> ()
    adjustArmPosition(motor_torque) == duration (0) (
        dcl t : real := time/1e9;
        dcl delta_t : real := t - last_time;
        dcl cos : real := MATH`cos(env_q);
        last_time := t;
        env_motor_torque := motor_torque;
        if (env_motor_state = <OFF>) then (
            env_motor_torque := 0.0;
        );


        env_friction_torque := friction_coulomb * tanh(env_dq) + friction_viscous * env_dq;
        
        -- env_ddq := (env_motor_torque + env_gravity_torque - env_friction_torque) / env_inertia;
        env_ddq := (env_motor_torque - env_friction_torque) / env_inertia;
        env_dq := env_dq + env_ddq * delta_t;
        env_q := env_q + env_dq * delta_t;
        recordState();
        
        -- env_gravity_torque := mass * gravity * radius * MATH`cos(env_q); -- Torque from gravity
    ) 
    pre (N1 <= env_qt and env_qt <= N2)
    post (env_q >= N1 and  env_q <= N2)
    

end Robot_arm